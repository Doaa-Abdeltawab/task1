"use strict";

// üìå Import Required Modules
let blindSignatures = require("blind-signatures");
let { BigInteger } = require("jsbn");
let crypto = require("crypto");

// üìå Constants
const COPIES_REQUIRED = 10;
const MAX_RANGE = 256;

// üìå Utility Function: Generate Secure Random Number
function sample() {
  return crypto.randomBytes(1).readUInt8();
}

// üìå Secure Random Integer Generator
function nextInt(range) {
  if (range > MAX_RANGE) {
    throw new Error(`Sorry, range cannot be more than ${MAX_RANGE}`);
  }

  let q = Math.floor(MAX_RANGE / range);
  let max = q * range;
  let n;
  do {
    n = sample();
  } while (n >= max);
  return n % range;
}

// üìå Modular Exponentiation Function (RSA)
function modExp(base, exp, mod) {
  let bigBase = new BigInteger(base.toString());
  let bigExp = new BigInteger(exp.toString());
  let bigMod = new BigInteger(mod.toString());
  return bigBase.modPow(bigExp, bigMod).intValue();
}

// üìå RSA Encryption & Decryption Functions
function encrypt(message, pubKey) {
  return modExp(message, pubKey.e, pubKey.modulus);
}

function decrypt(ciphertext, privKey) {
  return modExp(ciphertext, privKey.d, privKey.modulus);
}

function sign(message, privKey) {
  return decrypt(message, privKey);
}

function verify(message, sig, pubKey) {
  return encrypt(sig, pubKey) === message;
}

// üìå SpyAgency Class (Blind Signatures Implementation)
class SpyAgency {
  constructor() {
    this.key = blindSignatures.keyGeneration({ b: 2048 }); // 2048-bit key
  }

  // üìå Consistency Check
  consistent(blindHash, factor, hash) {
    let n = this.key.keyPair.n;
    let e = new BigInteger(this.key.keyPair.e.toString());
    let bigHash = new BigInteger(hash, 16);
    let computed = bigHash.multiply(factor.modPow(e, n)).mod(n).toString();
    return blindHash.toString() === computed;
  }

  // üìå Verify Document Contents
  verifyContents(blindHash, blindingFactor, originalDoc) {
    if (!originalDoc.match(/^The bearer of this signed document, .*, has full diplomatic immunity.$/)) {
      return false;
    }
    let h = blindSignatures.messageToHash(originalDoc);
    return this.consistent(blindHash, blindingFactor, h);
  }

  // üìå Sign Documents with Blind Signatures
  signDocument(blindDocs, response) {
    if (blindDocs.length !== COPIES_REQUIRED) {
      throw new Error(`Expected ${COPIES_REQUIRED} documents, received ${blindDocs.length}`);
    }

    let selected = nextInt(blindDocs.length);
    console.log(`Agency selected index: ${selected}`);

    response(selected, (blindingFactors, originalDocs) => {
      for (let i = 0; i < blindDocs.length; i++) {
        if (i === selected) continue;
        if (!this.verifyContents(blindDocs[i], blindingFactors[i], originalDocs[i])) {
          throw new Error(`Document ${i} is invalid`);
        }
      }
      return blindSignatures.sign({
        blinded: blindDocs[selected],
        key: this.key,
      });
    });
  }

  get n() {
    return this.key.keyPair.n.toString();
  }

  get e() {
    return this.key.keyPair.e.toString();
  }
}

// üìå Generate Cover Identity Document
function makeDocument(coverName) {
  return `The bearer of this signed document, ${coverName}, has full diplomatic immunity.`;
}

// üìå Blind Signature Functions
function blind(msg, agency) {
  return blindSignatures.blind({
    message: msg,
    N: agency.n,
    E: agency.e,
  });
}

function unblind(blindingFactor, sig, n) {
  return blindSignatures.unblind({
    signed: sig,
    N: n,
    r: blindingFactor,
  });
}

// üìå Setup Spy Agency & Cover Names
let agency = new SpyAgency();
const coverNames = ["James", "Natasha", "Ethan", "Jason", "Ava", "Noah", "Liam", "Olivia", "Sophia", "Mason"];

let blindDocs = [];
let blindingFactors = [];
let originalDocs = [];

// üìå Generate Blind Documents
coverNames.forEach(name => {
  let doc = makeDocument(name);
  let blindedObj = blind(doc, agency);

  if (!blindedObj || !blindedObj.blinded || !blindedObj.r) {
    console.error(`‚ùå Error: Failed to generate blind signature for ${name}`);
    return;
  }

  originalDocs.push(doc);
  blindDocs.push(blindedObj.blinded);
  blindingFactors.push(blindedObj.r);
});

// üìå Debugging Output
console.log("‚úÖ BlindDocs:", blindDocs.length, blindDocs);
console.log("‚úÖ Blinding Factors:", blindingFactors.length, blindingFactors);
console.log("‚úÖ Original Docs:", originalDocs.length, originalDocs);

// üìå Ensure Non-Empty BlindDocs Before Signing
if (blindDocs.length > 0) {
  console.log("üöÄ Calling signDocument with blindDocs...");

  agency.signDocument(blindDocs, (selected, verifyAndSign) => {
    if (selected < 0 || selected >= blindDocs.length) {
      console.error("‚ùå Error: Selected index out of range.");
      return;
    }

    let blindedSignature = verifyAndSign(blindingFactors, originalDocs);

    if (!blindedSignature) {
      console.error("‚ùå Error: Failed to generate blinded signature.");
      return;
    }

    let finalSignature = unblind(new BigInteger(blindingFactors[selected].toString()), blindedSignature, agency.n);

    let isValid = blindSignatures.verify({
      unblinded: finalSignature,
      N: agency.n,
      E: agency.e,
      message: originalDocs[selected],
    });

    console.log(`Signature for "${coverNames[selected]}" is ${isValid ? "valid ‚úÖ" : "invalid ‚ùå"}`);
  });
} else {
  console.error("‚ùå Error: blindDocs is empty! Check your loop.");
}
